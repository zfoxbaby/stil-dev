"""Utility to convert STIL files to simple GASC format.

This script demonstrates how to use the ``STILParser`` from the project to
parse a STIL file and extract a very small subset of the information.  The
result is written to a ``.gasc`` file with a structure similar to the one
requested in the user instructions.

The script is intentionally lightweight and only relies on the parse tree
structure generated by ``STILParser``.  It walks the tree and collects:

* The signal names declared in the ``Signals`` block.
* The vector data contained in pattern statements.
* Micro-instructions (``Call``, ``Loop``, ``Stop`` â€¦) that immediately
  precede a vector.
* The active waveform table (``W`` statement).

The produced ``.gasc`` file contains a header with the list of signals and a
``SPM_PATTERN (SCAN)`` block with one line per vector.  Each line contains the
vector data, the micro-instruction and the waveform table name, when
available.

Note
----
The repository does not ship the ``lark`` dependency that powers the parser.
Running this script requires installing ``lark`` into the environment.
"""

from __future__ import annotations

import os
import sys
from dataclasses import dataclass
from typing import List

try:  # Try importing the package as an installed dependency first
    from Semi_ATE.STIL.parsers.STILParser import STILParser
except ImportError:  # pragma: no cover - fallback for local execution
    repo_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    sys.path.insert(0, repo_root)
    from Semi_ATE.STIL.parsers.STILParser import STILParser

from lark import Tree, Token


@dataclass
class PatternLine:
    vec: str
    instr: str
    wft: str


def extract_signals(tree: Tree) -> List[str]:
    """Return a list with all signal names declared in the STIL file."""
    signals: List[str] = []
    #for node in tree.find_data("signals_list"):
    for node in tree.find_data("b_signals__signals_list"):
        token = node.children[0]
        if isinstance(token, Token):
            signals.append(token.value)
    return signals


def extract_pattern_lines(tree: Tree) -> List[PatternLine]:
    """Extract vector data together with micro-instruction and waveform info."""
    lines: List[PatternLine] = []
    current_wft = ""
    pending_instr = ""

    # Walk through pattern statements in order.
    for block in tree.find_data("pattern_block"):
        for stmt in block.children:
            if not isinstance(stmt, Tree):
                continue
            if stmt.data == "w_stmt":
                # W <waveform_table_name> ;
                for child in stmt.children:
                    if isinstance(child, Token):
                        current_wft = child.value
            elif stmt.data in ("call_stmt", "macro_stmt", "l_stmt", "ml_stmt",
                               "g_stmt", "b_stmt", "i_stmt", "s_stmt", "sc_stmt"):
                tokens = [c.value for c in stmt.children if isinstance(c, Token)]
                pending_instr = " ".join(tokens)
            elif stmt.data in ("v_stmt", "c_stmt", "f_stmt"):
                # Vector statements may contain multiple vec_data_block entries.
                for vec_block in stmt.find_data("vec_data_block"):
                    vec_token = vec_block.children[1]
                    vec_data = vec_token.value.strip() if isinstance(vec_token, Token) else ""
                    lines.append(PatternLine(vec=vec_data,
                                             instr=pending_instr,
                                             wft=current_wft))
                    pending_instr = ""
    return lines


def convert(stil_path: str, gasc_path: str) -> None:
    parser = STILParser(stil_path)
    tree = parser.parse_syntax(debug=True)

    signals = extract_signals(tree)
    patt_lines = extract_pattern_lines(tree)

    with open(gasc_path, "w", encoding="utf-8") as fh:
        fh.write("HEADER\n")
        fh.write("     " + ",".join(signals) + ";\n\n")
        fh.write("SPM_PATTERN (SCAN) {\n")
        for pl in patt_lines:
            fh.write(f"       *{pl.vec}* {pl.instr};")
            if pl.wft:
                fh.write(f"{pl.wft};")
            fh.write("\n")
        fh.write("}\n")


def main(argv: List[str]) -> int:
    if len(argv) != 3:
        print(f"Usage: {argv[0]} <input.stil> <output.gasc>")
        return 1
    convert(argv[1], argv[2])
    return 0


if __name__ == "__main__":  # pragma: no cover - simple CLI wrapper
    sys.argv = ["stil_to_gasc.py", 
            "tests/stil_files/pattern_block/syn_ok_pattern_block_1.stil", 
            "tests/result.gasc"]
    raise SystemExit(main(sys.argv))
