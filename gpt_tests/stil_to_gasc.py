"""Utility to convert STIL files to simple GASC format.

This script demonstrates how to use the ``STILParser`` from the project to
parse a STIL file and extract a very small subset of the information.  The
result is written to a ``.gasc`` file with a structure similar to the one
requested in the user instructions.

The script is intentionally lightweight and only relies on the parse tree
structure generated by ``STILParser``.  It walks the tree and collects:

* The signal names declared in the ``Signals`` block.
* The vector data contained in pattern statements.
* Micro-instructions (``Call``, ``Loop``, ``Stop`` â€¦) that immediately
  precede a vector.
* The active waveform table (``W`` statement).

The produced ``.gasc`` file contains a header with the list of signals and a
``SPM_PATTERN (SCAN)`` block with one line per vector.  Each line contains the
vector data, the micro-instruction and the waveform table name, when
available.

Note
----
The repository does not ship the ``lark`` dependency that powers the parser.
Running this script requires installing ``lark`` into the environment.
"""

from __future__ import annotations

import os
import sys
from dataclasses import dataclass
from typing import List

try:  # Try importing the package as an installed dependency first
    from Semi_ATE.STIL.parsers.STILParser import STILParser
except ImportError:  # pragma: no cover - fallback for local execution
    repo_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    sys.path.insert(0, repo_root)
    from Semi_ATE.STIL.parsers.STILParser import STILParser

from lark import Tree, Token


@dataclass
class PatternLine:
    vec: str
    instr: str
    wft: str


def extract_signals(tree: Tree) -> List[str]:
    """Return a list with all signal names declared in the STIL file."""
    signals: List[str] = []
    for node in tree.iter_subtrees():
        if node.data.endswith("signals_list"):
            for child in node.children:
                if isinstance(child, Token):
                    signals.append(child.value)
    return signals


def extract_pattern_lines(tree: Tree, signal_count: int) -> List[PatternLine]:
    """Extract pattern lines (vector + micro-instruction + waveform)."""
    lines: List[PatternLine] = []
    current_wft = ""
    wft_pending = False

    def emit(vec: str, instr: str) -> None:
        nonlocal wft_pending
        wft = current_wft if wft_pending else ""
        if wft_pending:
            wft_pending = False
        lines.append(PatternLine(vec=vec, instr=instr, wft=wft))

    def process(node: Tree) -> None:
        nonlocal current_wft, wft_pending

        if not isinstance(node, Tree):
            return

        data = node.data

        if data.endswith("pattern_statement"):
            for child in node.children:
                process(child)
            return

        if data.endswith("w_stmt"):
            tokens = [t.value for t in node.children if isinstance(t, Token)]
            if len(tokens) >= 2:
                current_wft = tokens[1]
                wft_pending = True
            return

        micro_tokens = [c.value for c in node.children if isinstance(c, Token)][:2]
        micro = " ".join(micro_tokens)

        has_vec = any(isinstance(ch, Tree) and ch.data.endswith("vec_block") for ch in node.children)
        nested = [ch for ch in node.children if isinstance(ch, Tree) and ch.data.endswith("pattern_statement")]

        if has_vec:
            vec = ""
            for vb in node.iter_subtrees():
                if isinstance(vb, Tree) and vb.data.endswith("vec_data_block"):
                    vec_tokens = [t.value for t in vb.scan_values(lambda c: isinstance(c, Token))]
                    if vec_tokens:
                        vec = vec_tokens[-1]
                        break
            emit(vec, micro)
            return

        if nested:
            start_idx = len(lines)
            for child in nested:
                process(child)
            end_idx = len(lines)
            if start_idx < end_idx:
                lines[start_idx].instr = micro
                lines[end_idx - 1].instr = "RETURN"
            return

        vec = "X" * signal_count
        emit(vec, micro)

    for block in tree.iter_subtrees():
        if isinstance(block, Tree) and block.data.endswith("pattern_block"):
            for stmt in block.children:
                process(stmt)

    return lines


def convert(stil_path: str, gasc_path: str) -> None:
    parser = STILParser(stil_path)
    tree = parser.parse_syntax(debug=True)

    signals = extract_signals(tree)
    patt_lines = extract_pattern_lines(tree, len(signals))

    with open(gasc_path, "w", encoding="utf-8") as fh:
        fh.write("HEADER\n")
        fh.write("     " + ",".join(signals) + ";\n\n")
        fh.write("SPM_PATTERN (SCAN) {\n")
        for pl in patt_lines:
            fh.write(f"       *{pl.vec}* {pl.instr};")
            if pl.wft:
                fh.write(f"{pl.wft};")
            fh.write("\n")
        fh.write("}\n")


def main(argv: List[str]) -> int:
    if len(argv) != 3:
        print(f"Usage: {argv[0]} <input.stil> <output.gasc>")
        return 1
    convert(argv[1], argv[2])
    return 0


if __name__ == "__main__":  # pragma: no cover - simple CLI wrapper
    raise SystemExit(main(sys.argv))
