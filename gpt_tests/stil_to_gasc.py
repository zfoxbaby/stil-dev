"""Utility to convert STIL files to simple GASC format.

This script demonstrates how to use the ``STILParser`` from the project to
parse a STIL file and extract a very small subset of the information.  The
result is written to a ``.gasc`` file with a structure similar to the one
requested in the user instructions.

The script is intentionally lightweight and only relies on the parse tree
structure generated by ``STILParser``.  It walks the tree and collects:

* The signal names declared in the ``Signals`` block.
* The vector data contained in pattern statements.
* Micro-instructions (``Call``, ``Loop``, ``Stop`` â€¦) that immediately
  precede a vector.
* The active waveform table (``W`` statement).

The produced ``.gasc`` file contains a header with the list of signals and a
``SPM_PATTERN (SCAN)`` block with one line per vector.  Each line contains the
vector data, the micro-instruction and the waveform table name, when
available.

Note
----
The repository does not ship the ``lark`` dependency that powers the parser.
Running this script requires installing ``lark`` into the environment.
"""

from __future__ import annotations

import os
import sys
from dataclasses import dataclass
from typing import List

try:  # Try importing the package as an installed dependency first
    from Semi_ATE.STIL.parsers.STILParser import STILParser
except ImportError:  # pragma: no cover - fallback for local execution
    repo_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    sys.path.insert(0, repo_root)
    from Semi_ATE.STIL.parsers.STILParser import STILParser

from lark import Tree, Token


@dataclass
class PatternLine:
    vec: str
    instr: str
    wft: str


def extract_signals(tree: Tree) -> List[str]:
    """Return a list with all signal names declared in the STIL file."""
    signals: List[str] = []
    for node in tree.iter_subtrees():
        if node.data.endswith("signals_list"):
            for child in node.children:
                if isinstance(child, Token):
                    signals.append(child.value)
    return signals


def extract_pattern_lines(tree: Tree) -> List[PatternLine]:
    """Extract vector data together with micro-instruction and waveform info."""
    lines: List[PatternLine] = []
    current_wft = ""
    pending_instr = ""

    def walk(node: Tree) -> None:
        nonlocal current_wft, pending_instr, lines

        if not isinstance(node, Tree):
            return

        data = node.data

        if data.endswith("pattern_statement"):
            for child in node.children:
                walk(child)
            return

        if data.endswith("w_stmt"):
            tokens = [t.value for t in node.scan_values(lambda c: isinstance(c, Token))]
            if len(tokens) >= 2:
                current_wft = tokens[1]
            return

        if data.endswith("call_stmt") or data.endswith("macro_stmt") or data.endswith("l_stmt") \
           or data.endswith("ml_stmt") or data.endswith("g_stmt") or data.endswith("b_stmt") \
           or data.endswith("i_stmt") or data.endswith("s_stmt") or data.endswith("sc_stmt"):
            tokens = [t.value for t in node.scan_values(lambda c: isinstance(c, Token))]
            pending_instr = " ".join(tokens)
            for child in node.children:
                walk(child)
            return

        if data.endswith("v_stmt") or data.endswith("c_stmt") or data.endswith("f_stmt"):
            for vec_block in node.iter_subtrees():
                if isinstance(vec_block, Tree) and vec_block.data.endswith("vec_data_block"):
                    tokens = [t.value for t in vec_block.scan_values(lambda c: isinstance(c, Token))]
                    if tokens:
                        vec_data = tokens[-1]
                        lines.append(PatternLine(vec=vec_data,
                                                 instr=pending_instr,
                                                 wft=current_wft))
                        pending_instr = ""
            return

        for child in node.children:
            walk(child)

    for block in tree.iter_subtrees():
        if isinstance(block, Tree) and block.data.endswith("pattern_block"):
            for stmt in block.children:
                walk(stmt)

    return lines


def convert(stil_path: str, gasc_path: str) -> None:
    parser = STILParser(stil_path)
    tree = parser.parse_syntax(debug=True)

    signals = extract_signals(tree)
    patt_lines = extract_pattern_lines(tree)

    with open(gasc_path, "w", encoding="utf-8") as fh:
        fh.write("HEADER\n")
        fh.write("     " + ",".join(signals) + ";\n\n")
        fh.write("SPM_PATTERN (SCAN) {\n")
        for pl in patt_lines:
            fh.write(f"       *{pl.vec}* {pl.instr};")
            if pl.wft:
                fh.write(f"{pl.wft};")
            fh.write("\n")
        fh.write("}\n")


def main(argv: List[str]) -> int:
    if len(argv) != 3:
        print(f"Usage: {argv[0]} <input.stil> <output.gasc>")
        return 1
    convert(argv[1], argv[2])
    return 0


if __name__ == "__main__":  # pragma: no cover - simple CLI wrapper
    raise SystemExit(main(sys.argv))
