"""Utility to convert STIL files to simple GASC format.

This script demonstrates how to use the ``STILParser`` from the project to
parse a STIL file and extract a very small subset of the information.  The
result is written to a ``.gasc`` file with a structure similar to the one
requested in the user instructions.

The script is intentionally lightweight and only relies on the parse tree
structure generated by ``STILParser``.  It walks the tree and collects:

* The signal names declared in the ``Signals`` block.
* The vector data contained in pattern statements.
* Micro-instructions (``Call``, ``Loop``, ``Stop`` …) that immediately
  precede a vector.
* The active waveform table (``W`` statement).

The produced ``.gasc`` file contains a header with the list of signals and a
``SPM_PATTERN (SCAN)`` block with one line per vector.  Each line contains the
vector data, the micro-instruction and the waveform table name, when
available.

Note
----
The repository does not ship the ``lark`` dependency that powers the parser.
Running this script requires installing ``lark`` into the environment.

OPTIMIZED VERSION with streaming output and real-time progress display.
"""

from __future__ import annotations

import os
import sys
from dataclasses import dataclass
from typing import List, Dict, Tuple
from TimingData import TimingData
from STILParserUtils import STILParserUtils
from STILParserTransformer import PatternStreamParserTransformer
from STILParserTransformer import map_instruction
from STILEventHandler import STILEventHandler
import Logger

try:  # Try importing the package as an installed dependency first
    from Semi_ATE.STIL.parsers.STILParser import STILParser
except ImportError:  # pragma: no cover - fallback for local execution
    repo_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    sys.path.insert(0, repo_root)
    from Semi_ATE.STIL.parsers.STILParser import STILParser


@dataclass
class PatternLine:
    """模式行数据结构"""
    vec: str      # 向量数据
    instr: str    # 微指令
    wft: str      # 波形表名称

class STILToGascStream(STILEventHandler):
    """Convert STIL files to a simple GASC-like format - STREAMING OPTIMIZED VERSION."""

    def __init__(self, stil_file, target_file, progress_callback=None, debug=False):
        """初始化转换器
        
        Args:
            stil_file: 输入STIL文件路径
            target_file: 输出GASC文件路径  
            progress_callback: 进度回调函数
            debug: 是否开启调试模式
        """
        self.stil_file = stil_file
        self.target_file = target_file
        self.file_size = -1  # 文件大小
        self.read_size = 0  # 已读取字节数
        
        # Pattern line tracking
        self.current_wft = ""
        self.wft_pending = False
        self.pat_header: List[str] = []
        
        # Streaming output - 在构造时打开文件流
        self.output_file = open(target_file, "w", encoding="utf-8") if target_file else None
        self.header_written = False
        self.pattern_section_started = False
        
        # Progress tracking
        self.vector_count = 0
        self.progress_callback = progress_callback

        self._stop_requested = False       # 停止标志

        self.debug = debug
        
        # 通用解析工具
        self.parser_utils = STILParserUtils(debug=debug)
        
        # Pattern 解析器（延迟初始化）
        self.pattern_parser = None
        
        # 信号和信号组（从header解析中获取）
        self.signals: Dict[str, str] = {}  # {信号名: 信号类型}
        self.signal_groups: Dict[str, List[str]] = {}
        self.timings: Dict[str, List] = {}  # Timing 数据
        self.used_signals: List[str] = []   # Pattern 使用的信号列表
        self.signal_count = 0
    
    def __del__(self):
        """析构时确保关闭文件流"""
        self.close()
    
    def stop(self):
        """请求停止转换"""
        self._stop_requested = True
        if self.pattern_parser:
            self.pattern_parser.stop()
        if self.progress_callback:
            self.progress_callback("用户请求停止转换...")

    # ========================== STILEventHandler 回调实现 ==========================
    
    def on_parse_start(self) -> None:
        """解析开始"""
        if not self.pattern_section_started:
            self.output_file.write("SPM_PATTERN (SCAN) {\n")
            self.pattern_section_started = True
    
    def on_header(self, header: Dict[str, str]) -> None:
        """头信息"""
        #self.output_file.write(header + "\n")

    def on_waveform_change(self, wft_name: str) -> None:
        """波形表切换"""
        self.current_wft = wft_name
        self.wft_pending = True
    
    def on_vector_start(self, pattern_burst_name: str) -> None:
        """解析开始时调用"""
        pass
    
    def on_annotation(self, annotation: str) -> None:
        """注释时调用"""
        pass
    
    def on_label(self, label_name: str) -> None:
        """遇到标签 - GASC 格式将 label 附加在向量行后面，暂存"""
        pass  # GASC 不需要单独的 label 行
    
    def on_vector(self, vec_data_list: List[Tuple[str, str]], 
                  instr: str = "", param: str = "") -> None:
        """遇到向量数据"""
        # 适配 Transformer 版本的 vec_data_list 格式
        # Transformer 返回: [(signal, data, instr, param, label, vector_address), ...]
        
        # 构建向量字符串
        vec_parts: List[str] = []
        
        for pat_key, wfc_str, instr, param, label, vector_address in vec_data_list:
            vec_parts.append(wfc_str)
        
        vec = "".join(vec_parts)
        
        # 如果向量长度小于信号数，补充 X
        if len(vec) < self.signal_count:
            vec += "X" * (self.signal_count - len(vec))
        
        # 转换向量字符（子类可覆盖）
        vec = self.transform_vec_char(vec)

        formatted_instr = vec_data_list[0][2] + " " + vec_data_list[0][3]
        
        # 格式化波形表
        wft = self.current_wft if self.wft_pending else ""
        if self.wft_pending:
            self.wft_pending = False
        
        # 写入向量行
        self._write_vector_line(vec, formatted_instr, wft, vec_data_list[0][4].strip())
        
        # 进度更新
        update_interval = 2000 if self.vector_count <= 10000 else 5000
        if self.progress_callback and self.vector_count % update_interval == 0:
            progress = self.read_size / self.file_size * 100 if self.file_size > 0 else 100
            self.progress_callback(f"已处理 {self.vector_count:,} 个向量块, 进度:{progress:.1f}%...")
    
    def on_procedure_call(self, proc_name: str, proc_content: str = "", vector_address: int = 0) -> None:
        """Call 指令 - 已在解析器中展开"""
        if not proc_content:
            # Procedure 未找到，输出 Call 指令
            vec = "X" * self.signal_count
            self.on_vector(vec, f"Call {proc_name}", "")
    
    def on_micro_instruction(self, label: str, instr: str, param: str = "", vector_address: int = 0) -> None:
        """其他微指令（Stop, Goto 等）"""
        vec = "X" * self.signal_count
        # 映射指令
        mapped_instr = map_instruction(instr)
        formatted_instr = f"{mapped_instr} {param}".strip() if param else mapped_instr
        self._write_vector_line(vec, formatted_instr, self.current_wft, "")
        self.current_wft = ""
    
    def on_parse_complete(self, vector_count: int) -> None:
        """解析完成"""
        self.output_file.write("}\n")
        if self.progress_callback:
            self.progress_callback(f"已处理 {vector_count:,} 个向量块，进度:100%...")
    
    def on_log(self, log: str) -> None:
        """解析完成"""
        if self.progress_callback:
            self.progress_callback(log)

    def on_parse_error(self, error_msg: str, statement: str = "") -> None:
        """解析错误"""
        self.progress_callback(f"解析错误: {error_msg}\n语句: {statement[:100]}...")
        Logger.error(error_msg, statement)
    
    # ========================== GASC 格式化方法 ==========================
    
    def _write_vector_line(self, vec: str, instr: str, wft: str, label: str) -> None:
        """写入向量行到输出文件
        
        Args:
            vec: 向量数据
            instr: 微指令
            wft: 波形表名称
            label: 标签
        """
        line = f"       *{vec}*"
        if instr.strip():
            line += f"#{instr.strip()}"
        if wft.strip():
            line += f";{wft}"
        if label.strip():
            line += f":{label.strip()}"
        self.output_file.write(line + "\n")
        
        self.vector_count += 1

    # ========================== main convert method ==========================
    def convert(self) -> int:
        """主转换函数：将STIL文件转换为GASC格式（流式输出）
        
        Returns:
            0: 成功, -1: 失败或停止
        """
        self.vector_count = 0
        
        if self.progress_callback:
            self.progress_callback("开始解析STIL文件...")
        
        # 获取文件大小
        self.file_size = os.path.getsize(self.stil_file) if os.path.exists(self.stil_file) else 0
        size_mb = self.file_size / (1024 * 1024)
        
        if self.progress_callback:
            self.progress_callback(f"文件大小: {size_mb:.1f}MB")
            self.progress_callback(f"打开文件: {self.stil_file}")
        
        try:
            # 1. 初始化 Pattern 解析器，读取信号信息（包括 pat_header）
            if self.progress_callback:
                self.progress_callback("开始提取信号/组/Timing内容...")
            
            self.pattern_parser = PatternStreamParserTransformer(self.stil_file, self, self.debug)
            self.used_signals = self.pattern_parser.read_stil_overview(
                print_log=True)
            
            if self._stop_requested:
                if self.progress_callback:
                    self.progress_callback("转换已被用户停止")
                return -1
            
            if not self.used_signals:
                if self.progress_callback:
                    self.progress_callback("未能提取到信号信息")
                return -1
            
            # 获取解析结果
            self.signals = self.pattern_parser.get_signals()
            self.signal_groups = self.pattern_parser.get_signal_groups()
            self.pat_header = self.pattern_parser.get_pat_header()
            self.timings = self.pattern_parser.get_timings()
            self.signal_count = len(self.used_signals)
            
            if self.progress_callback:
                self.progress_callback(f"Pattern 使用了 {self.signal_count} 个信号")
            
            # 2. 写入所有头部信息（文件流已在构造时打开）
            if not self.output_file:
                raise Exception("输出文件流未初始化")
            
            # 写入 Header（Pattern 使用的信号顺序）
            self.output_file.write("HEADER {\n")
            self.output_file.write("     " + ",".join(self.used_signals) + ";\n")
            self.output_file.write("}\n\n")
            
            # 写入 Signals
            self.output_file.write("Signals {\n")
            self.output_file.write("     " + ",".join(self.signals.keys()) + ";\n")
            self.output_file.write("}\n\n")
            
            # 写入 Signal Groups
            if self.signal_groups:
                self.output_file.write("SignalGroups {\n")
                for name, sigs in self.signal_groups.items():
                    self.output_file.write("     {} = '{}';\n".format(name, " + ".join(sigs)))
                self.output_file.write("}\n\n")
            
            # 写入 Timing
            if self.timings:
                self.output_file.write("Timing {\n")
                for key, timing_list in self.timings.items():
                    for td in timing_list:
                        self.output_file.write(f"     {td.wft}, {td.period}, ")
                        self.output_file.write(f"{td.signal}, {td.wfc}, ")
                        self.output_file.write(f"{td.t1}, {td.e1}, ")
                        self.output_file.write(f"{td.t2}, {td.e2}, ")
                        self.output_file.write(f"{td.t3}, {td.e3}, ")
                        self.output_file.write(f"{td.t4}, {td.e4};\n")
                self.output_file.write("}\n\n")
            
            if self.progress_callback:
                self.progress_callback("信号/组/Timing转换完成...")
                self.progress_callback("开始转换Pattern内容...")
            
            # 3. 解析并写入 Pattern
            self.pattern_parser.parse_patterns()
            
            # 4. 关闭文件
            self.close()
            
            if self._stop_requested:
                if self.progress_callback:
                    self.progress_callback(f"转换已停止！总共处理了 {self.vector_count} 个向量块")
                return -1
            else:
                if self.progress_callback:
                    self.progress_callback(f"转换完成！总共处理了 {self.vector_count} 个向量块")
                return 0
        
        except Exception as e:
            Logger.error(f"GASC转换失败: {e}", exc_info=True)
            if self.progress_callback:
                self.progress_callback(f"转换失败: {e}")
            if self.debug:
                import traceback
                traceback.print_exc()
            self.close()
            return -1

    def transform_vec_char(self, vec: str) -> str:
        """将vec中的字符转换为其他字符
        
        可以在子类中覆盖此方法实现自定义字符转换
        """
        return vec

    def close(self):
        if self.output_file and not self.output_file.closed:
            self.output_file.close()

    def flush(self):
        if self.output_file and not self.output_file.closed:
            self.output_file.flush()