"""Utility to convert STIL files to simple GASC format.

This script demonstrates how to use the ``STILParser`` from the project to
parse a STIL file and extract a very small subset of the information.  The
result is written to a ``.gasc`` file with a structure similar to the one
requested in the user instructions.

The script is intentionally lightweight and only relies on the parse tree
structure generated by ``STILParser``.  It walks the tree and collects:

* The signal names declared in the ``Signals`` block.
* The vector data contained in pattern statements.
* Micro-instructions (``Call``, ``Loop``, ``Stop`` …) that immediately
  precede a vector.
* The active waveform table (``W`` statement).

The produced ``.gasc`` file contains a header with the list of signals and a
``SPM_PATTERN (SCAN)`` block with one line per vector.  Each line contains the
vector data, the micro-instruction and the waveform table name, when
available.

Note
----
The repository does not ship the ``lark`` dependency that powers the parser.
Running this script requires installing ``lark`` into the environment.

OPTIMIZED VERSION with streaming output and real-time progress display.
"""

from __future__ import annotations

import os
import sys
from dataclasses import dataclass
from typing import List, Dict, Tuple
from TimingData import TimingData
from STILParserUtils import STILParserUtils
from STILParserTransformer import PatternEventHandler, PatternStreamParserTransformer

try:  # Try importing the package as an installed dependency first
    from Semi_ATE.STIL.parsers.STILParser import STILParser
except ImportError:  # pragma: no cover - fallback for local execution
    repo_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    sys.path.insert(0, repo_root)
    from Semi_ATE.STIL.parsers.STILParser import STILParser


@dataclass
class PatternLine:
    """模式行数据结构"""
    vec: str      # 向量数据
    instr: str    # 微指令
    wft: str      # 波形表名称

class STILToGascStream(PatternEventHandler):
    """Convert STIL files to a simple GASC-like format - STREAMING OPTIMIZED VERSION."""

    def __init__(self, stil_file, target_file, progress_callback=None, debug=False):
        """初始化转换器
        
        Args:
            stil_file: 输入STIL文件路径
            target_file: 输出GASC文件路径  
            progress_callback: 进度回调函数
            debug: 是否开启调试模式
        """
        self.stil_file = stil_file
        self.target_file = target_file
        self.file_size = -1  # 文件大小
        self.read_size = 0  # 已读取字节数
        
        # Pattern line tracking
        self.current_wft = ""
        self.wft_pending = False
        self.pat_header: List[str] = []
        self.need_append_header = True
        
        # Streaming output
        self.output_file = open(target_file, "w", encoding="utf-8")
        self.header_written = False
        self.pattern_section_started = False
        
        # Progress tracking
        self.vector_count = 0
        self.progress_callback = progress_callback

        self.header_placeholder_size = 0  # 记录预留的Header空间大小
        self.header_start_position = 0     # 记录Header开始位置
        self._stop_requested = False       # 停止标志

        self.debug = debug
        
        # 通用解析工具
        self.parser_utils = STILParserUtils(debug=debug)
        
        # Pattern 解析器（延迟初始化）
        self.pattern_parser = None
        
        # 信号和信号组（从header解析中获取）
        self.signals: Dict[str, str] = {}  # {信号名: 信号类型}
        self.signal_groups: Dict[str, List[str]] = {}
        self.signal_count = 0
    
    def stop(self):
        """请求停止转换"""
        self._stop_requested = True
        if self.pattern_parser:
            self.pattern_parser.stop()
        if self.progress_callback:
            self.progress_callback("用户请求停止转换...")

    # ========================== PatternEventHandler 回调实现 ==========================
    
    def on_parse_start(self) -> None:
        """解析开始"""
        if not self.pattern_section_started:
            self.output_file.write("SPM_PATTERN (SCAN) {\n")
            self.pattern_section_started = True
    
    def on_waveform_change(self, wft_name: str) -> None:
        """波形表切换"""
        self.current_wft = wft_name
        self.wft_pending = True
    
    def on_label(self, label_name: str) -> None:
        """遇到标签 - GASC 格式将 label 附加在向量行后面，暂存"""
        pass  # GASC 不需要单独的 label 行
    
    def on_vector(self, vec_data_list: List[Tuple[str, str]], 
                  instr: str = "", param: str = "") -> None:
        """遇到向量数据"""
        # 适配 Transformer 版本的 vec_data_list 格式
        # Transformer 返回: [(signal, data, instr, param, label), ...]
        
        # 构建向量字符串
        vec_parts: List[str] = []
        
        for pat_key, wfc_str, instr, param, label in vec_data_list:
            # 记录第一个 V 的 header
            if self.need_append_header:
                self.pat_header.append(pat_key)
            vec_parts.append(wfc_str)
        
        self.need_append_header = False
        vec = "".join(vec_parts)
        
        # 如果向量长度小于信号数，补充 X
        if len(vec) < self.signal_count:
            vec += "X" * (self.signal_count - len(vec))
        
        # 转换向量字符（子类可覆盖）
        vec = self.transform_vec_char(vec)

        formatted_instr = vec_data_list[0][2] + " " + vec_data_list[0][3]
        
        # 格式化波形表
        wft = self.current_wft if self.wft_pending else ""
        if self.wft_pending:
            self.wft_pending = False
        
        # 写入向量行
        self._write_vector_line(vec, formatted_instr, wft, vec_data_list[0][4].strip())
        
        # 进度更新
        update_interval = 1000 if self.vector_count <= 10000 else 5000
        if self.progress_callback and self.vector_count % update_interval == 0:
            progress = self.read_size / self.file_size * 100 if self.file_size > 0 else 100
            self.progress_callback(f"已处理 {self.vector_count:,} 个向量块, 进度:{progress:.1f}%...")
    
    def on_procedure_call(self, proc_name: str, proc_content: str = "") -> None:
        """Call 指令 - 已在解析器中展开"""
        if not proc_content:
            # Procedure 未找到，输出 Call 指令
            vec = "X" * self.signal_count
            self.on_vector(vec, f"Call {proc_name}", "")
    
    def on_micro_instruction(self, instr: str, param: str = "") -> None:
        """其他微指令（Stop, Goto 等）"""
        vec = "X" * self.signal_count
        formatted_instr = f"{instr} {param}".strip() if param else instr
        self._write_vector_line(vec, formatted_instr, self.current_wft, "")
        self.current_wft = ""
    
    def on_parse_complete(self, vector_count: int) -> None:
        """解析完成"""
        self.output_file.write("}\n")
        if self.progress_callback:
            self.progress_callback(f"已处理 {vector_count:,} 个向量块，进度:100%...")
    
    def on_parse_error(self, error_msg: str, statement: str = "") -> None:
        """解析错误"""
        if self.debug:
            if statement:
                print(f"解析错误: {error_msg}\n语句: {statement[:100]}...")
            else:
                print(f"解析错误: {error_msg}")
    
    # ========================== GASC 格式化方法 ==========================
    
    def _write_vector_line(self, vec: str, instr: str, wft: str, label: str) -> None:
        """写入向量行到输出文件
        
        Args:
            vec: 向量数据
            instr: 微指令
            wft: 波形表名称
            label: 标签
        """
        line = f"       *{vec}*"
        if instr.strip():
            line += f"#{instr.strip()}"
        if wft.strip():
            line += f";{wft}"
        if label.strip():
            line += f":{label.strip()}"
        self.output_file.write(line + "\n")
        
        self.vector_count += 1

    # ========================== main convert method ==========================
    def convert(self) -> int:
        """主转换函数：将STIL文件转换为GASC格式（流式输出）
        
        Returns:
            0: 成功, -1: 失败或停止
        """
        self.vector_count = 0
        
        if self.progress_callback:
            self.progress_callback("开始解析STIL文件...")
        
        # 获取文件大小
        self.file_size = os.path.getsize(self.stil_file) if os.path.exists(self.stil_file) else 0
        size_mb = self.file_size / (1024 * 1024)
        
        if self.progress_callback:
            self.progress_callback(f"文件大小: {size_mb:.1f}MB")
            self.progress_callback(f"打开文件: {self.stil_file}")
            self.progress_callback("开始提取信号/组/Timing内容...")
        
        # 解析文件头部（Signals/SignalGroups/Timing）
        header_buffer = ""
        is_pattern = False
        
        try:
            with open(self.stil_file, 'r', encoding='utf-8') as f:
                for line in f:
                    if self._stop_requested:
                        if self.progress_callback:
                            self.progress_callback("转换已被用户停止")
                        return -1
                    
                    if line.strip().startswith('Pattern ') and '{' in line:
                        is_pattern = True
                        break
                    
                    header_buffer += line
            
            # 解析头部
            if self.debug:
                print("Header buffer 大小:", len(header_buffer))
            
            if self.progress_callback:
                self.progress_callback("开始信号/组/Timing语法解析...")
            
            parser = STILParser(self.stil_file, propagate_positions=True, debug=self.debug)
            tree = parser.parse_content(header_buffer)
            
            if self.debug:
                print(tree.pretty())
            
            if self.progress_callback:
                self.progress_callback("信号/组/Timing语法解析完成...")
                self.progress_callback("开始转换信号/组定义...")
            
            # 使用通用解析工具
            self.signals = self.parser_utils.extract_signals(tree)
            self.signal_groups = self.parser_utils.extract_signal_groups(tree)
            self.signal_count = len(self.signals)
            
            if self.progress_callback:
                self.progress_callback(f"找到 {self.signal_count} 个信号...")
            
            # 预留 Header 空间
            estimated_header_size = self.signal_count * 255 + 1000
            self.header_start_position = self.output_file.tell()
            placeholder = " " * estimated_header_size + "\n"
            self.output_file.write(placeholder)
            self.header_placeholder_size = estimated_header_size
            
            # 写入 Signals
            self.output_file.write("Signals {\n")
            self.output_file.write("     " + ",".join(self.signals.keys()) + ";\n\n")
            self.output_file.write("}\n\n")
            
            # 写入 Signal Groups
            if self.signal_groups:
                self.output_file.write("SignalGroups {\n")
                for name, sigs in self.signal_groups.items():
                    self.output_file.write("     {} = '{}';\n".format(name, " + ".join(sigs)))
                self.output_file.write("}\n\n")
            
            # 写入 Timing
            self.output_file.write("Timing {\n")
            timings = self.parser_utils.extract_timings(tree, self.signals)
            for key, timing in timings.items():
                for timing_data in timing:
                    self.output_file.write(f"     {timing_data.wft}, {timing_data.period}, ")
                    self.output_file.write(f"{timing_data.signal}, {timing_data.wfc}, ")
                    self.output_file.write(f"{timing_data.t1}, {timing_data.e1}, ")
                    self.output_file.write(f"{timing_data.t2}, {timing_data.e2}, ")
                    self.output_file.write(f"{timing_data.t3}, {timing_data.e3}, ")
                    self.output_file.write(f"{timing_data.t4}, {timing_data.e4};\n")
            self.output_file.write("}\n\n")
            
            if self.progress_callback:
                self.progress_callback("信号/组/Timing转换完成...")
                self.progress_callback("开始转换Pattern内容...")
            
            # 初始化 Pattern 解析器并解析 - 使用 Transformer 版本
            self.pattern_parser = PatternStreamParserTransformer(self.stil_file, self, self.debug)
            self.pattern_parser.parse_patterns()
            
            # 关闭文件并完成收尾工作
            self.close()
            
            if self._stop_requested:
                if self.progress_callback:
                    self.progress_callback(f"正在完成Header写入（已处理 {self.vector_count} 个向量）...")
            
            self.finalize_header(self.signals, self.signal_groups)
            
            if self._stop_requested:
                if self.progress_callback:
                    self.progress_callback(f"转换已停止！总共处理了 {self.vector_count} 个向量块")
                return -1
            else:
                if self.progress_callback:
                    self.progress_callback(f"转换完成！总共处理了 {self.vector_count} 个向量块")
                return 0
        
        except Exception as e:
            if self.progress_callback:
                self.progress_callback(f"转换失败: {e}")
            if self.debug:
                import traceback
                traceback.print_exc()
            return -1

    def transform_vec_char(self, vec: str) -> str:
        """将vec中的字符转换为其他字符"""
        """
            wt1, 40ns, input_time_gen_0, 0, 0ns, D, , , , , , ;
            wt1, 40ns, input_time_gen_0, 1, 0ns, U, , , , , , ;
            wt1, 40ns, input_time_gen_0, N, 0ns, N, , , , , , ;
            wt1, 40ns, _po_, L, 10ns, l, , , , , , ;
            wt1, 40ns, _po_, H, 10ns, h, , , , , , ;
            wt1, 40ns, _po_, X, 10ns, X, , , , , , ;
            wt1, 40ns, _po_, T, 10ns, t, , , , , , ;
            wt1, 40ns, _po_, Z, 10ns, Z, , , , , , ;
            wt1, 40ns, _bidi_, 0, 0ns, Z, , , , , , ;
            wt1, 40ns, _bidi_, 1, 0ns, , , , , , , ;
            wt1, 40ns, _bidi_, Z, 0ns, , , , , , , ;
            wt1, 40ns, _bidi_, N, 0ns, , , , , , , ;
        """
        return vec


    def finalize_header(self, signals: Dict[str, str], sig_groups: dict[str, List[str]]) -> None:
        """完善文件头部，直接在预留空间中写入Header
        
        Args:
            signals: {信号名: 信号类型} 映射
            sig_groups: {组名: [信号列表]} 映射
        """
        # 确定最终的模式信号列表
        final_signals = []
        for key in self.pat_header:
            if key in sig_groups:
                final_signals.extend(sig_groups[key])
            elif key in signals:
                final_signals.append(key)
        
        # 生成Header内容
        header_content = "HEADER { \n"
        header_content += "     " + ",".join(final_signals) + ";\n"
        header_content += "}\n\n"
        
        # 检查Header大小是否超出预留空间
        if len(header_content) > self.header_placeholder_size:
            if self.progress_callback:
                self.progress_callback(f"警告：Header大小({len(header_content)})超出预留空间({self.header_placeholder_size})")
            # 如果超出，只能回退到使用临时文件的方式
            self._finalize_header_with_temp_file(final_signals)
            return
        
        # 在预留空间中填充实际的Header
        # 填充到预留大小，保证文件结构不变
        padded_header = header_content.ljust(self.header_placeholder_size) + "\n"
        
        # 打开文件，seek到Header开始位置，覆盖写入
        with open(self.target_file, "r+", encoding="utf-8") as f:
            f.seek(self.header_start_position)
            f.write(padded_header)

    def close(self):
        if self.output_file and not self.output_file.closed:
            self.output_file.close()

    def flush(self):
        if self.output_file and not self.output_file.closed:
            self.output_file.flush()